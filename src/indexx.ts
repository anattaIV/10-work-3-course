interface Post { //Интерфейс который типизирует структуру постов
  id: number;
  title: string;
  content: string;
}
//Посты
const posts: Post[] = [ //Массив объектов типизированных как Post. 
  { id: 1, title: "Hello world", content: "Первый пост" }, //"База данных" постов
  { id: 2, title: "TypeScript DOM", content: "Работа с элементами" },
  { id: 3, title: "Debounce пример", content: "Поиск с задержкой" }
];
//СВязываемся с HTML
const input = document.querySelector<HTMLInputElement>("#search"); //Поиск в HTML по ID. Типизация заключается в том что мы указываем <HTMLInputElement>. Каждый интерактивный элемент нужно указывать по разному
const button = document.querySelector<HTMLButtonElement>("#submitBtn"); //Чтобы работало корректно, то после этой типизации нужно проверить наличие элемента, т.к TS не связан с HTML(что и делается в след функции благодаря ?)
const list = document.querySelector<HTMLUListElement>("#results");
//Переменная снизу нужна для механизма debounce(пока пользователь вводит текст эта функция задерживает выполнение)
let timer: number | undefined; //Переменная,которая хранит в себе текущее значение таймера. number - текущее число таймера, undefined - когда таймер еще не создан или очищен. Нужен для debounce-поиска(происходит поиск через 300мс после последнего ввода, для того, чтобы не вызывать поиск на каждый символ.).
//Функция реализующая debounce поиск. Пользователь печатает, функция контролирует задержку и вызывает doSearch
input?.addEventListener("input", (event: InputEvent) => { //? - в данном случае заменяет if else. Если есть input - добавить обработчик, если нет, то ничего не делать. "input" - событие срабатывающее на изменение текста. (event: InputEvent) => - функция исполняется при каждом вводе текста(т.е каждый раз когда текст изменяется)
  clearTimeout(timer); //Очистка таймера(чтобы поиск выполнялся после паузы).
  timer = window.setTimeout(() => { //Запускается новый таймер на 300мс. Если пользователь перестал печатать, то выполнятся следующая функция:
    const target = event.target as HTMLInputElement; //Код который сработает после паузы. Здесь происходит сам поиск. event.target - элемент в котором произошло событие наше поле ввода
    doSearch(target.value); //Передаем значение из input в функцию. Запускает поиск.
  }, 300);
});
//Добавление нового поста и проверка на корректность данных
button?.addEventListener("click", (event: MouseEvent) => { //? если кнопка есть, то код выполнится, в любом другом случае нет. Тип события - клик мышкой, функция которая выполняется при нажатии
  event.preventDefault(); //Отмена дефолтного действия. В данном случае при нажатии на кнопку страница обновилась бы и вся инфомрмация из полей исчезла бы. При помощи этого свойства страница не обновляется и JS спокойно обрабатывает информацию.
  const form = document.querySelector<HTMLFormElement>("#searchForm"); //Поиск формы в HTML
  if (!form) return; //Проверка, что такая форма есть. !form без формы - код не продолжается

  const data = new FormData(form); //Создается объект, содержащий данные всех полей из формы
  const title = (data.get("title") as string)?.trim(); //Получаем поле со значением title. as string - приводим к строке чтобы избежать ошибок(говорим, что точно знаем, что это строка). trim() - убираем пробелы в начале и конце, ?. - пробелы убираются если поле не пустое. Если пустое то действие не выполняется.

  if (!title || title.length <= 3) {//!title  - если строка "", null, undef или длинна строки меньше или равно 3 символам, то...
    alert("Введите минимум 4 символа");//...то выводится уведомление 
    return;
  }

  simulateFetch({ id: Date.now(), title, content: "Новый пост" })//Создается объект. id: Date.now() - уникальный объект по времени, title - который ввел пользователь, content: "Новый пост" - фиксированная строка у всех постов.
    .then(res => { //сработает если simulateFetch вернет успешный результат. res - объект поста который мы передали
      alert("Пост успешно добавлен"); // уведомление
    })
    .catch(err => { //Если simulateFetch вызовет reject(ошибку) 
      if (err instanceof Error) alert(err.message); //Проверяем, что пришла настоящая ошибка и выводим уведомление
    });
});
//Главная функция для очистки поля поиска и отображение результата
function doSearch(query: string) { //функция в которой параметр принимает string
  if (!list) return; // list - элемент из DOM. Если его нет, то код выполняет нет смысла
  list.innerHTML = ""; //Очистка прошлых результатов. Удаляем все li из прошлых списков. Если это не сделать, то результаты будут накладываться друг на друга

  const filtered = posts.filter(p => //filter - создает новый массив с очищенными данными. 
    p.title.toLowerCase().includes(query.toLowerCase()) //p - 1 из постов массива. toLowerCase - переводим заголовок в нижний регистр. includes - проверяет содержит ли строка другую строку. query.toLowerCase() - тоже самое делаем с запросом.
  ); // в итоге filtered — это массив только тех постов, которые подходят под поисковый запрос.

  filtered.forEach(p => { //forEach - проходим по каждому отфильтрованному посту. 
    const li = document.createElement("li"); //Создаем li элемент
    li.innerText = `${p.id}. ${p.title}`; //Заполняем содержимое li(id и title)
    list.appendChild(li);//Добавляем li в ul(т.е выводим на экран)
  });
}
//Имитирует работу сервера и показывает асинхронность добавление поста
function simulateFetch(post: Post): Promise<Post> { //Функция которая симулирует запрос на сервер. Функция принимает только объекты типа Post. Функция возвращает промис, который при успехе вернет объект Post, а при ошибке выдаст Error.
  return new Promise((resolve, reject) => { //Создается новый промис у которого 2 инструмента. Успешное завершение и ошибка.
    setTimeout(() => { //Иммитация задержки на сервере
      if (post.title) resolve(post); //Если у поста есть title, то вызывает resolve(успешное завершение)
      else reject(new Error("Ошибка при добавлении поста")); //Если заголовок пустой, то вызываем ошибку.
    }, 500);
  });
}
